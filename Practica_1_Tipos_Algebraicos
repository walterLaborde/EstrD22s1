--1. Números enteros

-- 1. Defina las siguientes funciones:

-- a) 
sucesor :: Int -> Int
-- Dado un número devuelve su sucesor

sucesor n = n+1

-- b) 
sumar :: Int -> Int -> Int
-- Dados dos números devuelve su suma utilizando la operación +.

sumar n m = n+m

--c) 
divisionYResto :: Int -> Int -> (Int, Int)
{- Dado dos números, devuelve un par donde la primera componente es la división del
primero por el segundo, y la segunda componente es el resto de dicha división. Nota:
para obtener el resto de la división utilizar la función mod :: Int -> Int -> Int,
provista por Haskell.-}

divisionYResto n m = (div n m,mod n m)

--d) 
maxDelPar :: (Int,Int) -> Int
-- Dado un par de números devuelve el mayor de estos.

maxDelPar (n,m) = if (n>m)
                    then n 
                    else m


-- 2. De 4 ejemplos de expresiones diferentes que denoten el número 10, utilizando en cada expresión
-- a todas las funciones del punto anterior.
-- Ejemplo: maxDePar (divisionYResto (suma 5 5) (sucesor 0))

-- maxDelPar(divisionYResto 40 (sucesor 3))

-- maxDelPar(divisionYResto (sumar 9 1) (sucesor 0))

-- sumar 0 (maxDelPar(divisionYResto (sumar 9 1) (sucesor 0)))


--2. Tipos enumerativos

-- 1. Definir el tipo de dato Dir, con las alternativas Norte, Sur, Este y Oeste. Luego implementar
-- las siguientes funciones:

data Dir = Norte | Este | Sur | Oeste

-- a) 
opuesto :: Dir -> Dir
--Dada una dirección devuelve su opuesta.

opuesto d = case d of
    Norte -> Sur
    Este  -> Oeste
    Sur   -> Norte
    Oeste -> Este 

-- b) 
iguales :: Dir -> Dir -> Bool
-- Dadas dos direcciones, indica si son la misma. Nota: utilizar pattern matching y no ==.

iguales Norte Norte = True
iguales Este Este   = True
iguales Sur Sur     = True
iguales Oeste Oeste = True
iguales d1    d2    = False    

-- c) 
siguiente :: Dir -> Dir

siguiente d = case d of 
    Norte -> Este
    Este  -> Sur
    Sur   -> Oeste
    Oeste -> Norte 

{- Dada una dirección devuelve su siguiente, en sentido horario, y suponiendo que no existe
la siguiente dirección a Oeste. ¿Posee una precondición esta función? ¿Es una función
total o parcial? ¿Por qué? -}

-- 2. Definir el tipo de dato DiaDeSemana, con las alternativas Lunes, Martes, Miércoles, Jueves,
-- Viernes, Sabado y Domingo. Supongamos que el primer día de la semana es lunes, y el último
-- es domingo. Luego implementar las siguientes funciones:

data DiaDeSemana = Lunes | Martes | Miercoles | Jueves | Viernes | Sabado | Domingo

-- a) 
primeroYUltimoDia :: (DiaDeSemana, DiaDeSemana)
-- Devuelve un par donde la primera componente es el primer día de la semana, y la
-- segunda componente es el último día de la semana.

primerDia :: DiaDeSemana
primerDia = Lunes

ultimoDia :: DiaDeSemana
ultimoDia = Domingo

primeroYUltimoDia = (primerDia, ultimoDia)

--b) 
empiezaConM :: DiaDeSemana -> Bool
--Dado un dia de la semana indica si comienza con la letra M.

{-
opción 1
empiezaConM Martes    = True
empiezaConM Miercoles = True
empiezaConM otroDia   = False
-}

-- opción 2

empiezaConM d = esMartesOMiercoles d

esMartesOMiercoles :: DiaDeSemana -> Bool
esMartesOMiercoles Martes    = True
esMartesOMiercoles Miercoles = True 
esMartesOMiercoles otroDia   = False


--c) 
vieneDespues :: DiaDeSemana -> DiaDeSemana -> Bool
--Dado dos dias de semana, indica si el primero viene después que el segundo.

vieneDespues d1 d2 = diaEnNumero d1 > diaEnNumero d2

diaEnNumero :: DiaDeSemana -> Int

diaEnNumero Lunes     = 1
diaEnNumero Martes    = 2
diaEnNumero Miercoles = 3
diaEnNumero Jueves    = 4
diaEnNumero Viernes   = 5
diaEnNumero Sabado    = 6
diaEnNumero Domingo   = 7


--d) 
estaEnElMedio :: DiaDeSemana -> Bool
--Dado un dia de la semana indica si no es ni el primer ni el ultimo dia.

estaEnElMedio d = not (esLunesODomingo d)

esLunesODomingo :: DiaDeSemana -> Bool
esLunesODomingo Lunes = True
esLunesODomingo Domingo = True
esLunesODomingo otroDia = False

--3 BOOLEANOS

--a) 
negar :: Bool -> Bool
--Dado un booleano, si es True devuelve False, y si es False devuelve True.
--En Haskell ya está definida como not.

negar True  = False
negar False = True

--b) 
implica :: Bool -> Bool -> Bool
--Dados dos booleanos, si el primero es True y el segundo es False, devuelve False, sino
--devuelve True.
--Nota: no viene implementada en Haskell.

implica True False = False
implica _    _     = True

--c) 
and :: Bool -> Bool -> Bool
--Dados dos booleanos si ambos son True devuelve True, sino devuelve False.
--En Haskell ya está definida como \&\&.

and True True = True
and _    _    = False

--d) 
or :: Bool -> Bool -> Bool
--Dados dos booleanos si alguno de ellos es True devuelve True, sino devuelve False.
--En Haskell ya está definida como ||.

or True _    = True
or _    True = True
or _    _    = False
